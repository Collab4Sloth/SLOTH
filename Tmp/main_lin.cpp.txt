
#include <fstream>
#include <iostream>
#include "Solvers/AllenCahnSpecializedBilinearFormIntegrator.h"
#include "mfem.hpp"

using namespace std;
using namespace mfem;

////
/// Includes à mettre ailleurs, à généraliser, à optimiser...
///
double InitialOrderParameter(const Vector &x);
double radius;
// Compute the average value of alpha*n.Grad(sol) + beta*sol over the boundary
// attributes marked in bdr_marker. Also computes the L2 norm of
// alpha*n.Grad(sol) + beta*sol - gamma over the same boundary.
double IntegrateBC(const GridFunction &sol, const Array<int> &bdr_marker,
                   double alpha, double beta, double gamma, double &err);
///
class NLOperator : public Operator {
 private:
  NonlinearForm *N;
  mutable SparseMatrix *Jacobian;
  Coefficient *f;  // f in F(u) = -Laplace u + u^2 - f

 public:
  NLOperator(NonlinearForm *N_, Coefficient *f_, int size)
      : Operator(size), N(N_), f(f_), Jacobian(NULL) {}

  virtual void Mult(const Vector &x, Vector &y) const {
    N->Mult(x, y);
    y.Neg();
  }

  virtual Operator &GetGradient(const Vector &x) const {
    Jacobian = dynamic_cast<SparseMatrix *>(&N->GetGradient(x));
    return *Jacobian;
  }
};

int main(int argc, char *argv[]) {
  // 1. Parse command-line options.
  const char *mesh_file = "mesh_for_test.msh";
  int order = 1;
  bool static_cond = false;
  bool pa = false;
  const char *device_config = "cpu";
  bool visualization = true;
  bool algebraic_ceed = false;

  OptionsParser args(argc, argv);
  args.AddOption(&mesh_file, "-m", "--mesh", "Mesh file to use.");
  args.AddOption(&order, "-o", "--order",
                 "Finite element order (polynomial degree) or -1 for"
                 " isoparametric space.");
  args.AddOption(&static_cond, "-sc", "--static-condensation", "-no-sc",
                 "--no-static-condensation", "Enable static condensation.");
  args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                 "--no-partial-assembly", "Enable Partial Assembly.");
  args.AddOption(&device_config, "-d", "--device",
                 "Device configuration string, see Device::Configure().");
#ifdef MFEM_USE_CEED
  args.AddOption(&algebraic_ceed, "-a", "--algebraic", "-no-a",
                 "--no-algebraic", "Use algebraic Ceed solver");
#endif
  args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                 "--no-visualization",
                 "Enable or disable GLVis visualization.");
  args.Parse();
  if (!args.Good()) {
    args.PrintUsage(cout);
    return 1;
  }
  args.PrintOptions(cout);

  // 1. Enable hardware devices such as GPUs, and programming models such as
  //    CUDA, OCCA, RAJA and OpenMP based on command line options.
  Device device(device_config);
  device.Print();

  // 2. Read the mesh from the given mesh file. We can handle triangular,
  //    quadrilateral, tetrahedral, hexahedral, surface and volume meshes with
  //    the same code.
  Mesh mesh(mesh_file, 1, 1);
  int dim = mesh.Dimension();
  std::cout << "Dimension " << dim << std::endl;

  // 3. Define the ODE solver used for time integration. Several implicit
  //    singly diagonal implicit Runge-Kutta (SDIRK) methods, as well as
  //    explicit Runge-Kutta methods are available.
  //  ODESolver *ode_solver_tpe;
  std::unique_ptr<ForwardEulerSolver> ode_solver(new ForwardEulerSolver);

  // 4. Refine the mesh to increase the resolution. In this example we do
  //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
  //    largest number that gives a final mesh with no more than 50,000
  //    elements.
  {
    int ref_levels = 6;
    for (int l = 0; l < ref_levels; l++) {
      mesh.UniformRefinement();
    }
  }

  // 5. Define a finite element space on the mesh. Here we use continuous
  //    Lagrange finite elements of the specified order. If order < 1, we
  //    instead use an isoparametric/isogeometric space.
  H1_FECollection fec(order, dim);
  FiniteElementSpace fespace(&mesh, &fec);
  mfem::Vector minCoord, maxCoord;
  mesh.GetBoundingBox(minCoord, maxCoord);
  std::cout << "mesh size x = " << minCoord[0] << " " << maxCoord[0]
            << std::endl;
  std::cout << "mesh size y = " << minCoord[1] << " " << maxCoord[1]
            << std::endl;
  std::cout << "Number of finite element unknowns: " << fespace.GetTrueVSize()
            << std::endl;
  radius = maxCoord[0] - minCoord[0];

  // Coefficients
  auto _mobility(1.);
  ConstantCoefficient mobility(_mobility);
  auto _sigma(0.1);
  auto _epsilon(2.e-4);
  auto _lambda = -10.;  // * 1.5 * _sigma * _epsilon * _mobility;
  ConstantCoefficient lambda(_lambda);
  auto _meltingForce(-1.);
  ConstantCoefficient calphadContribution(-1.0 * _meltingForce * _mobility);

  // 6. Determine the list of true (i.e. conforming) essential boundary dofs.
  //    In this example, the boundary conditions are defined by marking
  //    the boundary attributes from the mesh as essential (Dirichlet), Natural
  //    (Neumann) and converting them to a list of true dofs.

  // Define two arrays containing boundar attributes numbers stored
  // "marker arrays" are used to define the portions of boundary associated
  //    with each type of boundary condition. These arrays have an entry
  //    corresponding to each boundary attribute.  Placing a '1' in entry i
  //    marks attribute i+1 as being active, '0' is inactive.
  // Here 1,2 NeumanHomogène, 3 Dirichlet
  Array<int> Dirichlet_bdr(mesh.bdr_attributes.Max());
  std::cout << " mesh.bdr_attributes.Max() " << mesh.bdr_attributes.Max()
            << std::endl;
  Dirichlet_bdr = 0;
  //  Dirichlet_bdr[0] = 1;
  Dirichlet_bdr[1] = 1;
  Dirichlet_bdr[2] = 1;
  // Dirichlet_bdr[3] = 1;
  auto _phiD = 1.;
  // Essential BdC = Dirichlet
  // Set the Dirichlet values in the solution vector
  Vector p_init(mesh.bdr_attributes.Max());
  //  p_init(0) = 1.00;
  p_init(1) = _phiD;
  p_init(2) = _phiD;
  // p_init(3) = _phiD;
  PWConstCoefficient dbr_value(p_init);
  //   4. Extract the list of all the boundary DOFs. These will be marked as
  //      Dirichlet in order to enforce  boundary conditions.
  Array<int> essential_tdof_list(0);
  fespace.GetEssentialTrueDofs(Dirichlet_bdr, essential_tdof_list);

  /////
  /// dphi/dt = -M [ Calphad + W'(phi) - Div(lambda Grad phi) ]
  /// -----------------------
  /// Variational formulation :
  /// -----------------------
  /// < dphi/dt, v >  + <M W'(phi), v > + < M lambda Grad phi, Grad v > =
  /// <-M Calphad, v> + < M  (n . lambda Grad phi), v >
  ///=============
  /// BilinearForm
  /// ------------
  /// < M lambda Grad phi, Grad v > := Diffusion Integrator
  /// <M W'(phi), v > :=
  ///=============
  /// LinearForm
  /// <-M Calphad, v> := DomainLFIntegrator(-M Calphad)
  ///============
  ///

  // GridFunctions definition
  GridFunction phi_GF(&fespace);

  // Set initial conditions
  FunctionCoefficient phi_0(InitialOrderParameter);
  phi_GF.ProjectCoefficient(phi_0);

  Vector phi;
  phi_GF.GetTrueDofs(phi);  // CCI pourquoi cette étape ?

  // 7. Set up the linear form b(.) which corresponds to the right-hand side of
  //    the FEM linear system, which in this case is (1,phi_i) where phi_i are
  //    the basis functions in the finite element fespace.
  LinearForm *b = new LinearForm(&fespace);
  //  LinearForm b(&fespace);

  b->AddDomainIntegrator(new DomainLFIntegrator(calphadContribution));
  b->Assemble();

  phi_GF.ProjectBdrCoefficient(dbr_value, Dirichlet_bdr);

  //  // 8. Define the solution vector x as a finite element grid function
  //  //    corresponding to fespace. Initialize x with initial guess of zero,
  //  //    which satisfies the boundary conditions.
  //  GridFunction x(&fespace);
  //  x = 0.0;

  // 9. Set up the bilinear form a(.,.) on the finite element space
  //    corresponding to the Laplacian operator -Delta, by adding the Diffusion
  //    domain integrator.
  BilinearForm a(&fespace);
  a.AddDomainIntegrator(new DiffusionIntegrator(lambda));
  //  a.AddDomainIntegrator(
  //      new AllenCahnSpecializedBilinearFormIntegrator(mobility));

  // 10. Assemble the bilinear form and the corresponding linear system,
  a.Assemble();
  OperatorPtr A;
  Vector B, X;
  a.FormLinearSystem(essential_tdof_list, phi_GF, *b, A, X, B);

  cout << "Size of linear system: " << A->Height() << endl;
  //
  ParaViewDataCollection *pd = NULL;

  // 15. Save data in the ParaView format
  ParaViewDataCollection paraview_dc("MainPST", &mesh);
  paraview_dc.SetPrefixPath("ParaView");
  paraview_dc.SetLevelsOfDetail(order);
  paraview_dc.SetCycle(0);
  paraview_dc.SetDataFormat(VTKFormat::BINARY);
  paraview_dc.SetHighOrderOutput(true);
  paraview_dc.SetTime(0.0);  // set the time
  paraview_dc.RegisterField("phi", &phi_GF);
  paraview_dc.Save();
  // 11. Solve the linear system A X = B.

  // If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
  cout << "UMFPackSolver start " << endl;
  UMFPackSolver umf_solver;
  umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
  umf_solver.SetOperator(*A);
  umf_solver.Mult(B, X);
  cout << "UMFPackSolver end " << endl;

  // 12. Recover the solution as a finite element grid function.
  cout << "RecoverFEMSolution start " << endl;
  a.RecoverFEMSolution(X, *b, phi_GF);
  cout << "RecoverFEMSolution end " << endl;

  // 15. Free the used memory.
  //  delete &fec;
  paraview_dc.SetCycle(1);
  paraview_dc.SetTime(1.0);
  paraview_dc.Save();

  // 14. Compute the various boundary integrals.
  mfem::out << endl
            << "Verifying boundary conditions" << endl
            << "=============================" << endl;
  {
    // Integrate the solution on the Dirichlet boundary and compare to the
    // expected value.
    double err, avg = IntegrateBC(phi_GF, Dirichlet_bdr, 0.0, 1.0, _phiD, err);

    bool hom_dbc = (_phiD == 2.0);
    err /= hom_dbc ? 1.0 : fabs(_phiD);
    mfem::out << "Average of solution on Gamma_dbc:\t" << avg << ", \t"
              << (hom_dbc ? "absolute" : "relative") << " error " << err
              << std::endl;
  }
  return 0;
}
///////////////////////////////////////////////////////////
/// TODO mettre dans un autre fichier avec des options
/// pour choisir entre heaviside, uniform....
///

double InitialOrderParameter(const Vector &x) {
  if (x.Norml2() < 0.5 * radius) {
    return 0.0;
  } else {
    return 1.0;
  }
}

double IntegrateBC(const GridFunction &x, const Array<int> &bdr, double alpha,
                   double beta, double gamma, double &err) {
  double nrm = 0.0;
  double avg = 0.0;
  err = 0.0;

  const bool a_is_zero = alpha == 0.0;
  const bool b_is_zero = beta == 0.0;

  const FiniteElementSpace &fes = *x.FESpace();
  MFEM_ASSERT(fes.GetVDim() == 1, "");
  Mesh &mesh = *fes.GetMesh();
  Vector shape, loc_dofs, w_nor;
  DenseMatrix dshape;
  Array<int> dof_ids;
  for (int i = 0; i < mesh.GetNBE(); i++) {
    if (bdr[mesh.GetBdrAttribute(i) - 1] == 0) {
      continue;
    }

    FaceElementTransformations *FTr = mesh.GetBdrFaceTransformations(i);
    if (FTr == nullptr) {
      continue;
    }

    const FiniteElement &fe = *fes.GetFE(FTr->Elem1No);
    MFEM_ASSERT(fe.GetMapType() == FiniteElement::VALUE, "");
    const int int_order = 2 * fe.GetOrder() + 3;
    const IntegrationRule &ir = IntRules.Get(FTr->FaceGeom, int_order);

    fes.GetElementDofs(FTr->Elem1No, dof_ids);
    x.GetSubVector(dof_ids, loc_dofs);
    if (!a_is_zero) {
      const int sdim = FTr->Face->GetSpaceDim();
      w_nor.SetSize(sdim);
      dshape.SetSize(fe.GetDof(), sdim);
    }
    if (!b_is_zero) {
      shape.SetSize(fe.GetDof());
    }
    for (int j = 0; j < ir.GetNPoints(); j++) {
      const IntegrationPoint &ip = ir.IntPoint(j);
      IntegrationPoint eip;
      FTr->Loc1.Transform(ip, eip);
      FTr->Face->SetIntPoint(&ip);
      double face_weight = FTr->Face->Weight();
      double val = 0.0;
      if (!a_is_zero) {
        FTr->Elem1->SetIntPoint(&eip);
        fe.CalcPhysDShape(*FTr->Elem1, dshape);
        CalcOrtho(FTr->Face->Jacobian(), w_nor);
        val += alpha * dshape.InnerProduct(w_nor, loc_dofs) / face_weight;
      }
      if (!b_is_zero) {
        fe.CalcShape(eip, shape);
        val += beta * (shape * loc_dofs);
      }

      // Measure the length of the boundary
      nrm += ip.weight * face_weight;

      // Integrate alpha * n.Grad(x) + beta * x
      avg += val * ip.weight * face_weight;

      // Integrate |alpha * n.Grad(x) + beta * x - gamma|^2
      val -= gamma;
      err += (val * val) * ip.weight * face_weight;
    }
  }

  // Normalize by the length of the boundary
  if (std::abs(nrm) > 0.0) {
    err /= nrm;
    avg /= nrm;
  }

  // Compute l2 norm of the error in the boundary condition (negative
  // quadrature weights may produce negative 'err')
  err = (err >= 0.0) ? sqrt(err) : -sqrt(-err);

  // Return the average value of alpha * n.Grad(x) + beta * x
  return avg;
}

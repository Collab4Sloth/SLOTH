/*
 * Solve Nonlinear Problem: -Laplace u + u^2 = f
 * Exact solution u_exact = sin(2*pi*x)
 *
 * Newton Linearization: Given u, solve du
 * -Laplace du + 2u*du = - F(u), where F(u) = -Laplace u + u^2 - f
 * */
#include <iostream>
#include "mfem.hpp"

using namespace std;
using namespace mfem;

// u = sin( 2 *  pi * x)
double u_exact_(const Vector& x) {
  MFEM_ASSERT(x.Size() == 1, "Must be 1D mesh");
  return sin(2 * M_PI * x[0]);
}

// -Laplace u + u^2 = f, deduced from analytic solution u_exact
double f_exact_(const Vector& x) {
  return 4 * M_PI * M_PI * sin(2 * M_PI * x[0]) +
         sin(2 * M_PI * x[0]) * sin(2 * M_PI * x[0]);
}

class NLFIntegrator : public NonlinearFormIntegrator {
 private:
  Vector shape;
  Coefficient* f;  // f in F(u)=-Laplace u + u^2 - f
  DenseMatrix dshape, dshapedxt, invdfdx;
  Vector vec, pointflux;

 public:
  NLFIntegrator(Coefficient* f_) : f(f_) {}
  virtual void AssembleElementVector(const FiniteElement& el,
                                     ElementTransformation& Tr,
                                     const Vector& elfun, Vector& elvect) {
    int dof = el.GetDof();
    int dim = el.GetDim();
    shape.SetSize(dof);
    dshape.SetSize(dof, dim);
    invdfdx.SetSize(dim);
    vec.SetSize(dim);
    pointflux.SetSize(dim);

    elvect.SetSize(dof);
    elvect = 0.0;

    const IntegrationRule* ir =
        &IntRules.Get(el.GetGeomType(), 2 * el.GetOrder() + Tr.OrderW());

    for (int i = 0; i < ir->GetNPoints(); i++) {
      const IntegrationPoint& ip = ir->IntPoint(i);
      el.CalcShape(ip, shape);
      Tr.SetIntPoint(&ip);

      // Given u, compute (u^2-f, v), v is shape function
      double fun_val = (elfun * shape) * (elfun * shape) - (*f).Eval(Tr, ip);
      double w = ip.weight * Tr.Weight() * fun_val;
      add(elvect, w, shape, elvect);

      // Given u, compute (grad(u), grad(v)), v is shape function. Ref:
      // DiffusionIntegrator::AssembleElementVector()
      CalcAdjugate(Tr.Jacobian(), invdfdx);
      dshape.MultTranspose(elfun, vec);
      invdfdx.MultTranspose(vec, pointflux);
      double ww = ip.weight / Tr.Weight();
      pointflux *= ww;
      invdfdx.Mult(pointflux, vec);
      dshape.AddMult(vec, elvect);
    }
  }

  virtual void AssembleElementGrad(const FiniteElement& el,
                                   ElementTransformation& Tr,
                                   const Vector& elfun, DenseMatrix& elmat) {
    int dof = el.GetDof();
    int dim = el.GetDim();
    dshapedxt.SetSize(dof, dim);
    dshape.SetSize(dof, dim);
    shape.SetSize(dof);
    elmat.SetSize(dof);
    elmat = 0.0;

    const IntegrationRule* ir =
        &IntRules.Get(el.GetGeomType(), 2 * el.GetOrder() + Tr.OrderW());

    for (int i = 0; i < ir->GetNPoints(); i++) {
      const IntegrationPoint& ip = ir->IntPoint(i);
      el.CalcShape(ip, shape);
      el.CalcDShape(ip, dshape);
      Tr.SetIntPoint(&ip);

      // Compute (grad(du), grad(v)).  Ref:
      // DiffusionIntegrator::AssembleElementMatrix()
      double w = ip.weight / Tr.Weight();
      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);  //
      AddMult_a_AAt(w, dshapedxt, elmat);

      // Compute 2*u*(du,v), v is shape function
      double fun_val = 2 * (elfun * shape) * ip.weight * Tr.Weight();  // 2*u
      AddMult_a_VVt(fun_val, shape, elmat);  // 2*u*(du, v)
    }
  }
};

class NLOperator : public Operator {
 private:
  NonlinearForm* N;
  mutable SparseMatrix* Jacobian;
  Coefficient* f;  // f in F(u) = -Laplace u + u^2 - f

 public:
  NLOperator(NonlinearForm* N_, Coefficient* f_, int size)
      : Operator(size), N(N_), f(f_), Jacobian(NULL) {}

  virtual void Mult(const Vector& x, Vector& y) const {
    N->Mult(x, y);
    y.Neg();
  }

  virtual Operator& GetGradient(const Vector& x) const {
    Jacobian = dynamic_cast<SparseMatrix*>(&N->GetGradient(x));
    return *Jacobian;
  }
};

int main() {
  Mesh mesh(20, 1.0);
  int dim = mesh.Dimension();

  H1_FECollection h1_fec(1, dim);
  FiniteElementSpace h1_space(&mesh, &h1_fec);
  int size = h1_space.GetVSize();

  Array<int> ess_tdof_list;
  if (mesh.bdr_attributes.Size()) {
    Array<int> ess_bdr(mesh.bdr_attributes.Max());
    ess_bdr = 1;
    h1_space.GetEssentialTrueDofs(ess_bdr, ess_tdof_list);
  }

  GridFunction rhs(&h1_space);
  FunctionCoefficient f_exact_coeff(f_exact_);
  rhs.ProjectCoefficient(f_exact_coeff);

  NonlinearForm N(&h1_space);
  N.AddDomainIntegrator(new NLFIntegrator(&f_exact_coeff));
  N.SetEssentialTrueDofs(ess_tdof_list);

  NLOperator N_oper(&N, &f_exact_coeff, size);

  Solver* J_solver;
  Solver* J_prec = new DSmoother(1);
  MINRESSolver* J_minres = new MINRESSolver;
  J_minres->SetPreconditioner(*J_prec);
  J_solver = J_minres;

  NewtonSolver newton_solver;
  newton_solver.SetSolver(*J_solver);
  newton_solver.SetOperator(N_oper);
  newton_solver.SetPrintLevel(1);

  GridFunction uh(&h1_space);
  Vector zero;
  newton_solver.Mult(zero, uh);

  FunctionCoefficient u_exact_coeff(u_exact_);
  cout << "L2 error norm: " << uh.ComputeL2Error(u_exact_coeff) << endl;
}
